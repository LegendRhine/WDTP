/*
  ==============================================================================

    SwingUtilities.h
    Created: 6 Sep 2016 10:53:31am
    Author:  SwingCoder

  ==============================================================================
*/

#ifndef SWINGUTILITIES_H_INCLUDED
#define SWINGUTILITIES_H_INCLUDED

//=========================================================================
// Macros...

/** Display a messageBox to indicate some code/func hasn't been completed.
    Note: Arg 'info' must be a String. */
#ifndef NEED_TO_DO
#define NEED_TO_DO(info) AlertWindow::showMessageBox (AlertWindow::InfoIcon, \
                         String (info), String (__FILE__) + newLine + \
                         "Line: " + String (__LINE__))
#endif

/** Replace AlertWindow::showMessageWindow() */
#ifndef SHOW_MESSAGE
#define SHOW_MESSAGE(info) AlertWindow::showMessageBox (AlertWindow::InfoIcon, TRANS("Message"), String(info))
#endif

/** Use for replace the JUCE DBG(), it'll show the file and line-number in console.
    Note: this macro also run in Release mode. */
#ifndef DBGX
#define DBGX(info) JUCE_BLOCK_WITH_FORCED_SEMICOLON (juce::String tempDbgBuf; \
                   tempDbgBuf << info << " -> " << String (__FILE__) << \
                   " - Line: " << String (__LINE__); \
                   juce::Logger::outputDebugString (tempDbgBuf);)
#endif

//=========================================================================
/** Some static methods and const value */
struct SwingUtilities
{    
    /** Return the platform-special font size */
    static const float getFontSize ()          { return 20.f; }

    /** Return the platform-special font name */
    static const String getFontName ()         { return "Microsoft YaHei"; }

    /** Display "About window" which can be used on Android platform.
        Arg 'shortDescription' (may app's name): the first text line inside the box with 
        brown colour and bigger size. */
    static void showAbout (const String& shortDescription, 
                           const String& copyrightYear);

    /** This method will change the default WebBroswerCompoennt's core on Windows.

        By default, JUCE using IE-7 web-core which cannot load any js script when 
        using WebBroswerComponent to display a html-page.

        After called, it will change the web-core to IE-11 on Windows (write to user's Windows register).
        This method should be called when the app is about to start. */
    static void fixWindowsRegistry();

    //=========================================================================
    /** Write an ValueTree to a file. */
    static const bool writeValueTreeToFile (const ValueTree& treeToWrite, 
                                            const File& fileToWriteTo,
                                            const bool usingGZipCompresData = false);
    
    /** Reads an ValueTree from the given file which was written by writeValueTreeToFile(). */
    static const ValueTree readValueTreeFromFile (const File& fileToReadFrom, 
                                                  const bool usingGZipCompresData = false);

    /** rename a file or dir */
    static bool renameFile (const File& file, const String& newName)
    {
        return file.moveFileTo (file.getSiblingFile (newName));
    }

    //=========================================================================
    /** Return such as "20150610112523" 
        (year + month + day + hour + minute + second, without " " and "-") */
    static const String getTimeString (const Time& time);

    /** Return such as "20150610112523" 
        (year + month + day + hour + minute + second, without " " and "-")

        plusDays: return currentTime + x days */
    static const String getCurrentTimeString (const int plusDays = 0);

    /** Convert a string such as "201506101125" to "2015.06.10 11:25:56" or "2015.06.10".

        The argument must be generated by getCurrentTimeString(), 
        otherwise it will return a String::empty. */
    static const String getTimeStringWithSeparator (const String& dateAndTimeString, 
                                                    bool includeTime);

    /** return: 2015-07-28 Mon 23:57:28. 
        The argument must be generated by getCurrentTimeString().

        If the argument is empty, it will return String::empty. */
    static const String getDateWeekdayAndTimeString (const String& dateAndTimeString);

    /** Return 3 letters weekday name. 
        The argument must be generated by getCurrentTimeString(). */
    static const String getWeekdayFromTimeString (const String& dateAndTimeString);

    /** if the argument valid and <= current time, then return true.

        The argument must be generated by getCurrentTimeString(), 
        otherwise it will return false.*/
    static const bool earlyThanCurrentTime (const String& dateAndTimeString);

    /** The Argument must be generated by getCurrentTimeString().

        if arg is empty, return today's Time. */
    static const Time getTimeFromString (const String& dateAndTimeString);

    /** if the given date and time string is valid, return true */
    static const bool isTimeStringValid (const String& dateAndTimeString);

    //=========================================================================
    /** Trim and replace all the invalid characters of the arg to '-', 
        then return an valid file/dir name string. */
    static const String getValidFileName (const String& originalStr);
    
    //==============================================================================
    /** Takes a string and returns a version of it where standard C++ escape sequences have been
     used to replace any non-ascii bytes.
     
     Although not strictly a tokenising function, this is still a function that often comes in
     handy when working with C++ code!
     
     @see writeEscapeChars
     */
    static String addEscapeChars (const String& s)
    {
        MemoryOutputStream mo;
        writeEscapeChars (mo, s.toRawUTF8(), -1, -1, false, true, true);
        return mo.toString();
    }
    
    //=======================================================================
private:
    /** Takes a UTF8 string and writes it to a stream using standard C++ escape sequences for any
     non-ascii bytes.
     
     Although not strictly a tokenising function, this is still a function that often comes in
     handy when working with C++ code!
     
     Note that addEscapeChars() is easier to use than this function if you're working with Strings.
     
     @see addEscapeChars
     */
    static void writeEscapeChars (OutputStream& out, const char* utf8, const int numBytesToRead,
                                  const int maxCharsOnLine, const bool breakAtNewLines,
                                  const bool replaceSingleQuotes, const bool allowStringBreaks)
    {
        int charsOnLine = 0;
        bool lastWasHexEscapeCode = false;
        bool trigraphDetected = false;
        
        for (int i = 0; i < numBytesToRead || numBytesToRead < 0; ++i)
        {
            const unsigned char c = (unsigned char) utf8[i];
            bool startNewLine = false;
            
            switch (c)
            {
                    
                case '\t':  out << "\\t";  trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; break;
                case '\r':  out << "\\r";  trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; break;
                case '\n':  out << "\\n";  trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; startNewLine = breakAtNewLines; break;
                case '\\':  out << "\\\\"; trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; break;
                case '\"':  out << "\\\""; trigraphDetected = false; lastWasHexEscapeCode = false; charsOnLine += 2; break;
                    
                case '?':
                    if (trigraphDetected)
                    {
                        out << "\\?";
                        charsOnLine++;
                        trigraphDetected = false;
                    }
                    else
                    {
                        out << "?";
                        trigraphDetected = true;
                    }
                    
                    lastWasHexEscapeCode = false;
                    charsOnLine++;
                    break;
                    
                case 0:
                    if (numBytesToRead < 0)
                        return;
                    
                    out << "\\0";
                    lastWasHexEscapeCode = true;
                    trigraphDetected = false;
                    charsOnLine += 2;
                    break;
                    
                case '\'':
                    if (replaceSingleQuotes)
                    {
                        out << "\\\'";
                        lastWasHexEscapeCode = false;
                        trigraphDetected = false;
                        charsOnLine += 2;
                        break;
                    }
                    
                    // deliberate fall-through...
                    
                default:
                    if (c >= 32 && c < 127 && ! (lastWasHexEscapeCode  // (have to avoid following a hex escape sequence with a valid hex digit)
                                                 && CharacterFunctions::getHexDigitValue (c) >= 0))
                    {
                        out << (char) c;
                        lastWasHexEscapeCode = false;
                        trigraphDetected = false;
                        ++charsOnLine;
                    }
                    else if (allowStringBreaks && lastWasHexEscapeCode && c >= 32 && c < 127)
                    {
                        out << "\"\"" << (char) c;
                        lastWasHexEscapeCode = false;
                        trigraphDetected = false;
                        charsOnLine += 3;
                    }
                    else
                    {
                        out << (c < 16 ? "\\x0" : "\\x") << String::toHexString ((int) c);
                        lastWasHexEscapeCode = true;
                        trigraphDetected = false;
                        charsOnLine += 4;
                    }
                    
                    break;
            }
            
            if ((startNewLine || (maxCharsOnLine > 0 && charsOnLine >= maxCharsOnLine))
                && (numBytesToRead < 0 || i < numBytesToRead - 1))
            {
                charsOnLine = 0;
                out << "\"" << newLine << "\"";
                lastWasHexEscapeCode = false;
            }
        }
    }

    
};

//=========================================================================
/** Can be used for single-line text input, such as search-input, title-input, etc.
    It will deliver the return-key event to its parent when user hit it.
*/
class InputTextEditor : public TextEditor
{
public:
    InputTextEditor (const String& componentName, juce_wchar passwordCharacter)
        : TextEditor (componentName, passwordCharacter)
    { }

    ~InputTextEditor () { }

    virtual bool keyPressed (const KeyPress& key) override
    {
        if (key == KeyPress::returnKey)
        {
            Component* parentComp = getParentComponent ();

            if (parentComp != nullptr)
                parentComp->keyPressed (key);

            return true;
        }

        return TextEditor::keyPressed (key);
    }

private:
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputTextEditor)
};

//==============================================================================
/** This class is used for replace AlertWindow's modal run,
    since that method can't compile on Android.     
    It can be used for register-window, complex-messageBox, etc.

    Usage: create object, add some widgets/components, set its size, 
    then call showDialog().
    
    Note: this class only allows to have one custom component.
    when add a custom component, must set its size first.
*/
class SwingDialog : public Component,
                    private Button::Listener
{
public:
    SwingDialog (const String& dialogTitle);
    ~SwingDialog ();

    void paint (Graphics&) override;
    void resized () override;

    /** set focus to the first text editor if there is one */
    void setFocus ();

    //=========================================================================
    void addButton (const String& btName, const KeyPress& shortKey);

    TextButton* getButton (const String& btName);

    //=========================================================================
    void addTextBlock (const String& content);

    void addTextEditor (const String& teName,
                        const String& content,
                        const String& labelTip = String::empty,
                        const bool isPw = false,
                        const bool readOnly = false);

    TextEditor* getTextEditor (const String& teName);
    const String getTextEditorContents (const String& editorName);

    //=========================================================================
    void addCustomComponent (Component* comp);

    /** Popup a modal dialog window to show */
    void showDialog (const String& windowTitle);

    virtual bool keyPressed (const KeyPress& key) override;

private:
    //=========================================================================
    virtual void buttonClicked (Button*) override;

    const Image logo;  // underwaySoft logo, size: 165 * 105

    ScopedPointer<Label> titleLb;
    OwnedArray<TextButton> bts;
    OwnedArray<Label> inputLbs;
    OwnedArray<InputTextEditor> inputs;
    OwnedArray<TextEditor> blocks;
    ScopedPointer<Component> custComp;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SwingDialog)
};

//=========================================================================
/** Change the default backgroud colour of the parent class */
class StrechableBar : public StretchableLayoutResizerBar
{
public:
    StrechableBar (StretchableLayoutManager *layoutToUse, 
                   int itemIndexInLayout, 
                   bool isBarVertical)
        : StretchableLayoutResizerBar (layoutToUse, itemIndexInLayout, isBarVertical)
    {

    }

    //=========================================================================
    void paint (Graphics& g) override
    {
        g.setColour (isMouseOver () ? Colours::lightskyblue : Colour (0x00));
        g.fillAll ();
    }

    //=========================================================================
    virtual void mouseEnter(const MouseEvent& ) override
    {
        repaint ();
    }

    virtual void mouseExit(const MouseEvent& ) override
    {
        repaint ();
    }

    //=========================================================================
private:

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (StrechableBar)
};

//=========================================================================
/** ColourSelector with preset colour-blocks */
class ColourSelectorWithPreset : public ColourSelector
{
public:
    ColourSelectorWithPreset ();

    int getNumSwatches () const override                 { return colours.size (); }
    Colour getSwatchColour (int index) const override    { return colours[index]; }
    
    void setSwatchColour (int index, const Colour& newColour) const override;

private:
    //=================================================================================================
    static Array<Colour> colours;    
    static void setPresetDefaultColour ();  

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ColourSelectorWithPreset)
};


#endif  // SWINGUTILITIES_H_INCLUDED
